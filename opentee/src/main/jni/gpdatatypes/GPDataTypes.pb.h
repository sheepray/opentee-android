// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GPDataTypes.proto

#ifndef PROTOBUF_GPDataTypes_2eproto__INCLUDED
#define PROTOBUF_GPDataTypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace fi {
namespace aalto {
namespace ssg {
namespace opentee {
namespace imps {
namespace pbdatatypes {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GPDataTypes_2eproto();
void protobuf_AssignDesc_GPDataTypes_2eproto();
void protobuf_ShutdownFile_GPDataTypes_2eproto();

class TeecOperation;
class TeecParameter;
class TeecSharedMemory;
class TeecSharedMemoryReference;
class TeecValue;

enum TeecParameter_Type {
  TeecParameter_Type_smr = 1,
  TeecParameter_Type_val = 2
};
bool TeecParameter_Type_IsValid(int value);
const TeecParameter_Type TeecParameter_Type_Type_MIN = TeecParameter_Type_smr;
const TeecParameter_Type TeecParameter_Type_Type_MAX = TeecParameter_Type_val;
const int TeecParameter_Type_Type_ARRAYSIZE = TeecParameter_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TeecParameter_Type_descriptor();
inline const ::std::string& TeecParameter_Type_Name(TeecParameter_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TeecParameter_Type_descriptor(), value);
}
inline bool TeecParameter_Type_Parse(
    const ::std::string& name, TeecParameter_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TeecParameter_Type>(
    TeecParameter_Type_descriptor(), name, value);
}
enum TeecSharedMemoryReference_Flag {
  TeecSharedMemoryReference_Flag_TEEC_MEMREF_INPUT = 0,
  TeecSharedMemoryReference_Flag_TEEC_MEMREF_OUTPUT = 1,
  TeecSharedMemoryReference_Flag_TEEC_MEMREF_INOUT = 2
};
bool TeecSharedMemoryReference_Flag_IsValid(int value);
const TeecSharedMemoryReference_Flag TeecSharedMemoryReference_Flag_Flag_MIN = TeecSharedMemoryReference_Flag_TEEC_MEMREF_INPUT;
const TeecSharedMemoryReference_Flag TeecSharedMemoryReference_Flag_Flag_MAX = TeecSharedMemoryReference_Flag_TEEC_MEMREF_INOUT;
const int TeecSharedMemoryReference_Flag_Flag_ARRAYSIZE = TeecSharedMemoryReference_Flag_Flag_MAX + 1;

const ::google::protobuf::EnumDescriptor* TeecSharedMemoryReference_Flag_descriptor();
inline const ::std::string& TeecSharedMemoryReference_Flag_Name(TeecSharedMemoryReference_Flag value) {
  return ::google::protobuf::internal::NameOfEnum(
    TeecSharedMemoryReference_Flag_descriptor(), value);
}
inline bool TeecSharedMemoryReference_Flag_Parse(
    const ::std::string& name, TeecSharedMemoryReference_Flag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TeecSharedMemoryReference_Flag>(
    TeecSharedMemoryReference_Flag_descriptor(), name, value);
}
enum TeecValue_Flag {
  TeecValue_Flag_TEEC_VALUE_INPUT = 0,
  TeecValue_Flag_TEEC_VALUE_OUTPUT = 1,
  TeecValue_Flag_TEEC_VALUE_INOUT = 2
};
bool TeecValue_Flag_IsValid(int value);
const TeecValue_Flag TeecValue_Flag_Flag_MIN = TeecValue_Flag_TEEC_VALUE_INPUT;
const TeecValue_Flag TeecValue_Flag_Flag_MAX = TeecValue_Flag_TEEC_VALUE_INOUT;
const int TeecValue_Flag_Flag_ARRAYSIZE = TeecValue_Flag_Flag_MAX + 1;

const ::google::protobuf::EnumDescriptor* TeecValue_Flag_descriptor();
inline const ::std::string& TeecValue_Flag_Name(TeecValue_Flag value) {
  return ::google::protobuf::internal::NameOfEnum(
    TeecValue_Flag_descriptor(), value);
}
inline bool TeecValue_Flag_Parse(
    const ::std::string& name, TeecValue_Flag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TeecValue_Flag>(
    TeecValue_Flag_descriptor(), name, value);
}
// ===================================================================

class TeecOperation : public ::google::protobuf::Message {
 public:
  TeecOperation();
  virtual ~TeecOperation();

  TeecOperation(const TeecOperation& from);

  inline TeecOperation& operator=(const TeecOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeecOperation& default_instance();

  void Swap(TeecOperation* other);

  // implements Message ----------------------------------------------

  TeecOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeecOperation& from);
  void MergeFrom(const TeecOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mStarted = 1;
  inline bool has_mstarted() const;
  inline void clear_mstarted();
  static const int kMStartedFieldNumber = 1;
  inline ::google::protobuf::int32 mstarted() const;
  inline void set_mstarted(::google::protobuf::int32 value);

  // repeated .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter mParams = 2;
  inline int mparams_size() const;
  inline void clear_mparams();
  static const int kMParamsFieldNumber = 2;
  inline const ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter& mparams(int index) const;
  inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter* mutable_mparams(int index);
  inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter* add_mparams();
  inline const ::google::protobuf::RepeatedPtrField< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter >&
      mparams() const;
  inline ::google::protobuf::RepeatedPtrField< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter >*
      mutable_mparams();

  // @@protoc_insertion_point(class_scope:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecOperation)
 private:
  inline void set_has_mstarted();
  inline void clear_has_mstarted();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter > mparams_;
  ::google::protobuf::int32 mstarted_;
  friend void  protobuf_AddDesc_GPDataTypes_2eproto();
  friend void protobuf_AssignDesc_GPDataTypes_2eproto();
  friend void protobuf_ShutdownFile_GPDataTypes_2eproto();

  void InitAsDefaultInstance();
  static TeecOperation* default_instance_;
};
// -------------------------------------------------------------------

class TeecParameter : public ::google::protobuf::Message {
 public:
  TeecParameter();
  virtual ~TeecParameter();

  TeecParameter(const TeecParameter& from);

  inline TeecParameter& operator=(const TeecParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeecParameter& default_instance();

  void Swap(TeecParameter* other);

  // implements Message ----------------------------------------------

  TeecParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeecParameter& from);
  void MergeFrom(const TeecParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TeecParameter_Type Type;
  static const Type smr = TeecParameter_Type_smr;
  static const Type val = TeecParameter_Type_val;
  static inline bool Type_IsValid(int value) {
    return TeecParameter_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TeecParameter_Type_Type_MIN;
  static const Type Type_MAX =
    TeecParameter_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TeecParameter_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TeecParameter_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TeecParameter_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TeecParameter_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter_Type type() const;
  inline void set_type(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter_Type value);

  // optional .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference teecSharedMemoryReference = 2;
  inline bool has_teecsharedmemoryreference() const;
  inline void clear_teecsharedmemoryreference();
  static const int kTeecSharedMemoryReferenceFieldNumber = 2;
  inline const ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference& teecsharedmemoryreference() const;
  inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference* mutable_teecsharedmemoryreference();
  inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference* release_teecsharedmemoryreference();
  inline void set_allocated_teecsharedmemoryreference(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference* teecsharedmemoryreference);

  // optional .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecValue teecValue = 3;
  inline bool has_teecvalue() const;
  inline void clear_teecvalue();
  static const int kTeecValueFieldNumber = 3;
  inline const ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue& teecvalue() const;
  inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue* mutable_teecvalue();
  inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue* release_teecvalue();
  inline void set_allocated_teecvalue(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue* teecvalue);

  // @@protoc_insertion_point(class_scope:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_teecsharedmemoryreference();
  inline void clear_has_teecsharedmemoryreference();
  inline void set_has_teecvalue();
  inline void clear_has_teecvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference* teecsharedmemoryreference_;
  ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue* teecvalue_;
  int type_;
  friend void  protobuf_AddDesc_GPDataTypes_2eproto();
  friend void protobuf_AssignDesc_GPDataTypes_2eproto();
  friend void protobuf_ShutdownFile_GPDataTypes_2eproto();

  void InitAsDefaultInstance();
  static TeecParameter* default_instance_;
};
// -------------------------------------------------------------------

class TeecSharedMemory : public ::google::protobuf::Message {
 public:
  TeecSharedMemory();
  virtual ~TeecSharedMemory();

  TeecSharedMemory(const TeecSharedMemory& from);

  inline TeecSharedMemory& operator=(const TeecSharedMemory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeecSharedMemory& default_instance();

  void Swap(TeecSharedMemory* other);

  // implements Message ----------------------------------------------

  TeecSharedMemory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeecSharedMemory& from);
  void MergeFrom(const TeecSharedMemory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes mBuffer = 1;
  inline bool has_mbuffer() const;
  inline void clear_mbuffer();
  static const int kMBufferFieldNumber = 1;
  inline const ::std::string& mbuffer() const;
  inline void set_mbuffer(const ::std::string& value);
  inline void set_mbuffer(const char* value);
  inline void set_mbuffer(const void* value, size_t size);
  inline ::std::string* mutable_mbuffer();
  inline ::std::string* release_mbuffer();
  inline void set_allocated_mbuffer(::std::string* mbuffer);

  // required int32 mFlag = 2;
  inline bool has_mflag() const;
  inline void clear_mflag();
  static const int kMFlagFieldNumber = 2;
  inline ::google::protobuf::int32 mflag() const;
  inline void set_mflag(::google::protobuf::int32 value);

  // required int32 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional int32 mReturnSize = 4;
  inline bool has_mreturnsize() const;
  inline void clear_mreturnsize();
  static const int kMReturnSizeFieldNumber = 4;
  inline ::google::protobuf::int32 mreturnsize() const;
  inline void set_mreturnsize(::google::protobuf::int32 value);

  // optional int32 mID = 5;
  inline bool has_mid() const;
  inline void clear_mid();
  static const int kMIDFieldNumber = 5;
  inline ::google::protobuf::int32 mid() const;
  inline void set_mid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory)
 private:
  inline void set_has_mbuffer();
  inline void clear_has_mbuffer();
  inline void set_has_mflag();
  inline void clear_has_mflag();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_mreturnsize();
  inline void clear_has_mreturnsize();
  inline void set_has_mid();
  inline void clear_has_mid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mbuffer_;
  ::google::protobuf::int32 mflag_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 mreturnsize_;
  ::google::protobuf::int32 mid_;
  friend void  protobuf_AddDesc_GPDataTypes_2eproto();
  friend void protobuf_AssignDesc_GPDataTypes_2eproto();
  friend void protobuf_ShutdownFile_GPDataTypes_2eproto();

  void InitAsDefaultInstance();
  static TeecSharedMemory* default_instance_;
};
// -------------------------------------------------------------------

class TeecSharedMemoryReference : public ::google::protobuf::Message {
 public:
  TeecSharedMemoryReference();
  virtual ~TeecSharedMemoryReference();

  TeecSharedMemoryReference(const TeecSharedMemoryReference& from);

  inline TeecSharedMemoryReference& operator=(const TeecSharedMemoryReference& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeecSharedMemoryReference& default_instance();

  void Swap(TeecSharedMemoryReference* other);

  // implements Message ----------------------------------------------

  TeecSharedMemoryReference* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeecSharedMemoryReference& from);
  void MergeFrom(const TeecSharedMemoryReference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TeecSharedMemoryReference_Flag Flag;
  static const Flag TEEC_MEMREF_INPUT = TeecSharedMemoryReference_Flag_TEEC_MEMREF_INPUT;
  static const Flag TEEC_MEMREF_OUTPUT = TeecSharedMemoryReference_Flag_TEEC_MEMREF_OUTPUT;
  static const Flag TEEC_MEMREF_INOUT = TeecSharedMemoryReference_Flag_TEEC_MEMREF_INOUT;
  static inline bool Flag_IsValid(int value) {
    return TeecSharedMemoryReference_Flag_IsValid(value);
  }
  static const Flag Flag_MIN =
    TeecSharedMemoryReference_Flag_Flag_MIN;
  static const Flag Flag_MAX =
    TeecSharedMemoryReference_Flag_Flag_MAX;
  static const int Flag_ARRAYSIZE =
    TeecSharedMemoryReference_Flag_Flag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Flag_descriptor() {
    return TeecSharedMemoryReference_Flag_descriptor();
  }
  static inline const ::std::string& Flag_Name(Flag value) {
    return TeecSharedMemoryReference_Flag_Name(value);
  }
  static inline bool Flag_Parse(const ::std::string& name,
      Flag* value) {
    return TeecSharedMemoryReference_Flag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes parent = 1;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 1;
  inline const ::std::string& parent() const;
  inline void set_parent(const ::std::string& value);
  inline void set_parent(const char* value);
  inline void set_parent(const void* value, size_t size);
  inline ::std::string* mutable_parent();
  inline ::std::string* release_parent();
  inline void set_allocated_parent(::std::string* parent);

  // required int32 mOffset = 2;
  inline bool has_moffset() const;
  inline void clear_moffset();
  static const int kMOffsetFieldNumber = 2;
  inline ::google::protobuf::int32 moffset() const;
  inline void set_moffset(::google::protobuf::int32 value);

  // required .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.Flag mFlag = 3;
  inline bool has_mflag() const;
  inline void clear_mflag();
  static const int kMFlagFieldNumber = 3;
  inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference_Flag mflag() const;
  inline void set_mflag(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference_Flag value);

  // @@protoc_insertion_point(class_scope:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference)
 private:
  inline void set_has_parent();
  inline void clear_has_parent();
  inline void set_has_moffset();
  inline void clear_has_moffset();
  inline void set_has_mflag();
  inline void clear_has_mflag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* parent_;
  ::google::protobuf::int32 moffset_;
  int mflag_;
  friend void  protobuf_AddDesc_GPDataTypes_2eproto();
  friend void protobuf_AssignDesc_GPDataTypes_2eproto();
  friend void protobuf_ShutdownFile_GPDataTypes_2eproto();

  void InitAsDefaultInstance();
  static TeecSharedMemoryReference* default_instance_;
};
// -------------------------------------------------------------------

class TeecValue : public ::google::protobuf::Message {
 public:
  TeecValue();
  virtual ~TeecValue();

  TeecValue(const TeecValue& from);

  inline TeecValue& operator=(const TeecValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeecValue& default_instance();

  void Swap(TeecValue* other);

  // implements Message ----------------------------------------------

  TeecValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeecValue& from);
  void MergeFrom(const TeecValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TeecValue_Flag Flag;
  static const Flag TEEC_VALUE_INPUT = TeecValue_Flag_TEEC_VALUE_INPUT;
  static const Flag TEEC_VALUE_OUTPUT = TeecValue_Flag_TEEC_VALUE_OUTPUT;
  static const Flag TEEC_VALUE_INOUT = TeecValue_Flag_TEEC_VALUE_INOUT;
  static inline bool Flag_IsValid(int value) {
    return TeecValue_Flag_IsValid(value);
  }
  static const Flag Flag_MIN =
    TeecValue_Flag_Flag_MIN;
  static const Flag Flag_MAX =
    TeecValue_Flag_Flag_MAX;
  static const int Flag_ARRAYSIZE =
    TeecValue_Flag_Flag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Flag_descriptor() {
    return TeecValue_Flag_descriptor();
  }
  static inline const ::std::string& Flag_Name(Flag value) {
    return TeecValue_Flag_Name(value);
  }
  static inline bool Flag_Parse(const ::std::string& name,
      Flag* value) {
    return TeecValue_Flag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 a = 1;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 1;
  inline ::google::protobuf::int32 a() const;
  inline void set_a(::google::protobuf::int32 value);

  // required int32 b = 2;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 2;
  inline ::google::protobuf::int32 b() const;
  inline void set_b(::google::protobuf::int32 value);

  // required .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecValue.Flag mFlag = 3;
  inline bool has_mflag() const;
  inline void clear_mflag();
  static const int kMFlagFieldNumber = 3;
  inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue_Flag mflag() const;
  inline void set_mflag(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue_Flag value);

  // @@protoc_insertion_point(class_scope:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecValue)
 private:
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_b();
  inline void clear_has_b();
  inline void set_has_mflag();
  inline void clear_has_mflag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 a_;
  ::google::protobuf::int32 b_;
  int mflag_;
  friend void  protobuf_AddDesc_GPDataTypes_2eproto();
  friend void protobuf_AssignDesc_GPDataTypes_2eproto();
  friend void protobuf_ShutdownFile_GPDataTypes_2eproto();

  void InitAsDefaultInstance();
  static TeecValue* default_instance_;
};
// ===================================================================


// ===================================================================

// TeecOperation

// required int32 mStarted = 1;
inline bool TeecOperation::has_mstarted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeecOperation::set_has_mstarted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeecOperation::clear_has_mstarted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeecOperation::clear_mstarted() {
  mstarted_ = 0;
  clear_has_mstarted();
}
inline ::google::protobuf::int32 TeecOperation::mstarted() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecOperation.mStarted)
  return mstarted_;
}
inline void TeecOperation::set_mstarted(::google::protobuf::int32 value) {
  set_has_mstarted();
  mstarted_ = value;
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecOperation.mStarted)
}

// repeated .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter mParams = 2;
inline int TeecOperation::mparams_size() const {
  return mparams_.size();
}
inline void TeecOperation::clear_mparams() {
  mparams_.Clear();
}
inline const ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter& TeecOperation::mparams(int index) const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecOperation.mParams)
  return mparams_.Get(index);
}
inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter* TeecOperation::mutable_mparams(int index) {
  // @@protoc_insertion_point(field_mutable:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecOperation.mParams)
  return mparams_.Mutable(index);
}
inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter* TeecOperation::add_mparams() {
  // @@protoc_insertion_point(field_add:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecOperation.mParams)
  return mparams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter >&
TeecOperation::mparams() const {
  // @@protoc_insertion_point(field_list:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecOperation.mParams)
  return mparams_;
}
inline ::google::protobuf::RepeatedPtrField< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter >*
TeecOperation::mutable_mparams() {
  // @@protoc_insertion_point(field_mutable_list:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecOperation.mParams)
  return &mparams_;
}

// -------------------------------------------------------------------

// TeecParameter

// required .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter.Type type = 1;
inline bool TeecParameter::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeecParameter::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeecParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeecParameter::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter_Type TeecParameter::type() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter.type)
  return static_cast< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter_Type >(type_);
}
inline void TeecParameter::set_type(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter_Type value) {
  assert(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter.type)
}

// optional .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference teecSharedMemoryReference = 2;
inline bool TeecParameter::has_teecsharedmemoryreference() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeecParameter::set_has_teecsharedmemoryreference() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeecParameter::clear_has_teecsharedmemoryreference() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeecParameter::clear_teecsharedmemoryreference() {
  if (teecsharedmemoryreference_ != NULL) teecsharedmemoryreference_->::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference::Clear();
  clear_has_teecsharedmemoryreference();
}
inline const ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference& TeecParameter::teecsharedmemoryreference() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter.teecSharedMemoryReference)
  return teecsharedmemoryreference_ != NULL ? *teecsharedmemoryreference_ : *default_instance_->teecsharedmemoryreference_;
}
inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference* TeecParameter::mutable_teecsharedmemoryreference() {
  set_has_teecsharedmemoryreference();
  if (teecsharedmemoryreference_ == NULL) teecsharedmemoryreference_ = new ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference;
  // @@protoc_insertion_point(field_mutable:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter.teecSharedMemoryReference)
  return teecsharedmemoryreference_;
}
inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference* TeecParameter::release_teecsharedmemoryreference() {
  clear_has_teecsharedmemoryreference();
  ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference* temp = teecsharedmemoryreference_;
  teecsharedmemoryreference_ = NULL;
  return temp;
}
inline void TeecParameter::set_allocated_teecsharedmemoryreference(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference* teecsharedmemoryreference) {
  delete teecsharedmemoryreference_;
  teecsharedmemoryreference_ = teecsharedmemoryreference;
  if (teecsharedmemoryreference) {
    set_has_teecsharedmemoryreference();
  } else {
    clear_has_teecsharedmemoryreference();
  }
  // @@protoc_insertion_point(field_set_allocated:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter.teecSharedMemoryReference)
}

// optional .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecValue teecValue = 3;
inline bool TeecParameter::has_teecvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeecParameter::set_has_teecvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeecParameter::clear_has_teecvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeecParameter::clear_teecvalue() {
  if (teecvalue_ != NULL) teecvalue_->::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue::Clear();
  clear_has_teecvalue();
}
inline const ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue& TeecParameter::teecvalue() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter.teecValue)
  return teecvalue_ != NULL ? *teecvalue_ : *default_instance_->teecvalue_;
}
inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue* TeecParameter::mutable_teecvalue() {
  set_has_teecvalue();
  if (teecvalue_ == NULL) teecvalue_ = new ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue;
  // @@protoc_insertion_point(field_mutable:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter.teecValue)
  return teecvalue_;
}
inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue* TeecParameter::release_teecvalue() {
  clear_has_teecvalue();
  ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue* temp = teecvalue_;
  teecvalue_ = NULL;
  return temp;
}
inline void TeecParameter::set_allocated_teecvalue(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue* teecvalue) {
  delete teecvalue_;
  teecvalue_ = teecvalue;
  if (teecvalue) {
    set_has_teecvalue();
  } else {
    clear_has_teecvalue();
  }
  // @@protoc_insertion_point(field_set_allocated:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecParameter.teecValue)
}

// -------------------------------------------------------------------

// TeecSharedMemory

// required bytes mBuffer = 1;
inline bool TeecSharedMemory::has_mbuffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeecSharedMemory::set_has_mbuffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeecSharedMemory::clear_has_mbuffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeecSharedMemory::clear_mbuffer() {
  if (mbuffer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mbuffer_->clear();
  }
  clear_has_mbuffer();
}
inline const ::std::string& TeecSharedMemory::mbuffer() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mBuffer)
  return *mbuffer_;
}
inline void TeecSharedMemory::set_mbuffer(const ::std::string& value) {
  set_has_mbuffer();
  if (mbuffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mbuffer_ = new ::std::string;
  }
  mbuffer_->assign(value);
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mBuffer)
}
inline void TeecSharedMemory::set_mbuffer(const char* value) {
  set_has_mbuffer();
  if (mbuffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mbuffer_ = new ::std::string;
  }
  mbuffer_->assign(value);
  // @@protoc_insertion_point(field_set_char:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mBuffer)
}
inline void TeecSharedMemory::set_mbuffer(const void* value, size_t size) {
  set_has_mbuffer();
  if (mbuffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mbuffer_ = new ::std::string;
  }
  mbuffer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mBuffer)
}
inline ::std::string* TeecSharedMemory::mutable_mbuffer() {
  set_has_mbuffer();
  if (mbuffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mbuffer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mBuffer)
  return mbuffer_;
}
inline ::std::string* TeecSharedMemory::release_mbuffer() {
  clear_has_mbuffer();
  if (mbuffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mbuffer_;
    mbuffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TeecSharedMemory::set_allocated_mbuffer(::std::string* mbuffer) {
  if (mbuffer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mbuffer_;
  }
  if (mbuffer) {
    set_has_mbuffer();
    mbuffer_ = mbuffer;
  } else {
    clear_has_mbuffer();
    mbuffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mBuffer)
}

// required int32 mFlag = 2;
inline bool TeecSharedMemory::has_mflag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeecSharedMemory::set_has_mflag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeecSharedMemory::clear_has_mflag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeecSharedMemory::clear_mflag() {
  mflag_ = 0;
  clear_has_mflag();
}
inline ::google::protobuf::int32 TeecSharedMemory::mflag() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mFlag)
  return mflag_;
}
inline void TeecSharedMemory::set_mflag(::google::protobuf::int32 value) {
  set_has_mflag();
  mflag_ = value;
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mFlag)
}

// required int32 size = 3;
inline bool TeecSharedMemory::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeecSharedMemory::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeecSharedMemory::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeecSharedMemory::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 TeecSharedMemory::size() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.size)
  return size_;
}
inline void TeecSharedMemory::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.size)
}

// optional int32 mReturnSize = 4;
inline bool TeecSharedMemory::has_mreturnsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeecSharedMemory::set_has_mreturnsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeecSharedMemory::clear_has_mreturnsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeecSharedMemory::clear_mreturnsize() {
  mreturnsize_ = 0;
  clear_has_mreturnsize();
}
inline ::google::protobuf::int32 TeecSharedMemory::mreturnsize() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mReturnSize)
  return mreturnsize_;
}
inline void TeecSharedMemory::set_mreturnsize(::google::protobuf::int32 value) {
  set_has_mreturnsize();
  mreturnsize_ = value;
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mReturnSize)
}

// optional int32 mID = 5;
inline bool TeecSharedMemory::has_mid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeecSharedMemory::set_has_mid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeecSharedMemory::clear_has_mid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeecSharedMemory::clear_mid() {
  mid_ = 0;
  clear_has_mid();
}
inline ::google::protobuf::int32 TeecSharedMemory::mid() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mID)
  return mid_;
}
inline void TeecSharedMemory::set_mid(::google::protobuf::int32 value) {
  set_has_mid();
  mid_ = value;
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemory.mID)
}

// -------------------------------------------------------------------

// TeecSharedMemoryReference

// required bytes parent = 1;
inline bool TeecSharedMemoryReference::has_parent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeecSharedMemoryReference::set_has_parent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeecSharedMemoryReference::clear_has_parent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeecSharedMemoryReference::clear_parent() {
  if (parent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_->clear();
  }
  clear_has_parent();
}
inline const ::std::string& TeecSharedMemoryReference::parent() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.parent)
  return *parent_;
}
inline void TeecSharedMemoryReference::set_parent(const ::std::string& value) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_ = new ::std::string;
  }
  parent_->assign(value);
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.parent)
}
inline void TeecSharedMemoryReference::set_parent(const char* value) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_ = new ::std::string;
  }
  parent_->assign(value);
  // @@protoc_insertion_point(field_set_char:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.parent)
}
inline void TeecSharedMemoryReference::set_parent(const void* value, size_t size) {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_ = new ::std::string;
  }
  parent_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.parent)
}
inline ::std::string* TeecSharedMemoryReference::mutable_parent() {
  set_has_parent();
  if (parent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parent_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.parent)
  return parent_;
}
inline ::std::string* TeecSharedMemoryReference::release_parent() {
  clear_has_parent();
  if (parent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parent_;
    parent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TeecSharedMemoryReference::set_allocated_parent(::std::string* parent) {
  if (parent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parent_;
  }
  if (parent) {
    set_has_parent();
    parent_ = parent;
  } else {
    clear_has_parent();
    parent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.parent)
}

// required int32 mOffset = 2;
inline bool TeecSharedMemoryReference::has_moffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeecSharedMemoryReference::set_has_moffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeecSharedMemoryReference::clear_has_moffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeecSharedMemoryReference::clear_moffset() {
  moffset_ = 0;
  clear_has_moffset();
}
inline ::google::protobuf::int32 TeecSharedMemoryReference::moffset() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.mOffset)
  return moffset_;
}
inline void TeecSharedMemoryReference::set_moffset(::google::protobuf::int32 value) {
  set_has_moffset();
  moffset_ = value;
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.mOffset)
}

// required .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.Flag mFlag = 3;
inline bool TeecSharedMemoryReference::has_mflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeecSharedMemoryReference::set_has_mflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeecSharedMemoryReference::clear_has_mflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeecSharedMemoryReference::clear_mflag() {
  mflag_ = 0;
  clear_has_mflag();
}
inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference_Flag TeecSharedMemoryReference::mflag() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.mFlag)
  return static_cast< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference_Flag >(mflag_);
}
inline void TeecSharedMemoryReference::set_mflag(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference_Flag value) {
  assert(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference_Flag_IsValid(value));
  set_has_mflag();
  mflag_ = value;
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecSharedMemoryReference.mFlag)
}

// -------------------------------------------------------------------

// TeecValue

// required int32 a = 1;
inline bool TeecValue::has_a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeecValue::set_has_a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeecValue::clear_has_a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeecValue::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline ::google::protobuf::int32 TeecValue::a() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecValue.a)
  return a_;
}
inline void TeecValue::set_a(::google::protobuf::int32 value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecValue.a)
}

// required int32 b = 2;
inline bool TeecValue::has_b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeecValue::set_has_b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeecValue::clear_has_b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeecValue::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline ::google::protobuf::int32 TeecValue::b() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecValue.b)
  return b_;
}
inline void TeecValue::set_b(::google::protobuf::int32 value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecValue.b)
}

// required .fi.aalto.ssg.opentee.imps.pbdatatypes.TeecValue.Flag mFlag = 3;
inline bool TeecValue::has_mflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeecValue::set_has_mflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeecValue::clear_has_mflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeecValue::clear_mflag() {
  mflag_ = 0;
  clear_has_mflag();
}
inline ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue_Flag TeecValue::mflag() const {
  // @@protoc_insertion_point(field_get:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecValue.mFlag)
  return static_cast< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue_Flag >(mflag_);
}
inline void TeecValue::set_mflag(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue_Flag value) {
  assert(::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue_Flag_IsValid(value));
  set_has_mflag();
  mflag_ = value;
  // @@protoc_insertion_point(field_set:fi.aalto.ssg.opentee.imps.pbdatatypes.TeecValue.mFlag)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbdatatypes
}  // namespace imps
}  // namespace opentee
}  // namespace ssg
}  // namespace aalto
}  // namespace fi

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter_Type>() {
  return ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecParameter_Type_descriptor();
}
template <> struct is_proto_enum< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference_Flag> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference_Flag>() {
  return ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecSharedMemoryReference_Flag_descriptor();
}
template <> struct is_proto_enum< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue_Flag> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue_Flag>() {
  return ::fi::aalto::ssg::opentee::imps::pbdatatypes::TeecValue_Flag_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GPDataTypes_2eproto__INCLUDED
